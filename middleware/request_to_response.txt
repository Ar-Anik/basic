-> Assume this middleware setting:
MIDDLEWARE = [
    'M1',
    'M2',
    'M3',
    'M4',
]

Step-1: Django Application Startup
What happens:
    * Django initializes your project.
    * Django processes the MIDDLEWARE list.
    * It builds the middleware chain in reverse order.

-> Chain building process (once, at startup):
get_response = view_function
get_response = M4(get_response)
get_response = M3(get_response)
get_response = M2(get_response)
get_response = M1(get_response)

Django reverses the middleware chain because it wraps middleware like layers of an onion — the outermost
middleware (top of the list) must be the first to be called on the request and the last to process the
response. This wrapping builds a chain where M1 wraps M2, which wraps M3, ..., which wraps the final view.
M1 is the outermost wrapper, so it’s called first when a request comes in. M4 is closest to the view, so
it’s called last before the view.

Note: The view here is not actually our real view function yet — it's a core internal Django function
that resolves the URL later. That function is:
            django.core.handlers.base.BaseHandler._get_response(request)
Inside _get_response(request) (used as the final get_response callable in the middleware chain), Django does
this :
    1. Resolves the URL: resolver_match = self.urlconf.resolve(request.path_info)
       Finds the view function that matches the URL.
    2. Calls the view: response = callback(request, *callback_args, **callback_kwargs)
       So middleware like M4 is not calling your actual view — it’s calling the final get_response, which
       resolves the view and then calls it.


Step-2: HTTP Request Comes In
What happens:
    * A client (browser, API client) sends an HTTP request.
    * The request reaches Django through WSGI/ASGI.
    * Django now calls the full get_response(request)/Middleware chain.


Step-3: Request Flow Through Middleware (Top-Down)
    request
      ↓
    M1.__call__(request)
      ↓
    M2.__call__(request)
      ↓
    M3.__call__(request)
      ↓
    M4.__call__(request)
      ↓
    → Django resolves URL and finds the view
    → Actual view function is called
      ↓
    response

Each middleware’s __call__() method receives the request and decides what to do:
    * It can modify the request
    * It can short-circuit and return a response (like AuthenticationMiddleware, CORSMiddleware, etc.)
    * Or it can call get_response(request) to pass it to the next middleware (or the view)

-> Short-circuiting means:
    * Stopping the normal flow of request processing.
    * Middleware returns a response without passing the request further (no deeper middleware or view).
    * It’s useful for access control, error handling, maintenance mode, etc.

A middleware can intercept the request and return a response immediately, without letting the request
reach later middleware or the view.

Normally, request flow looks like:
    M1 → M2 → M3 → M4 → View → Response → M4 → M3 → M2 → M1

But if a middleware short-circuits, the flow changes,Let's say M2 short-circuits (e.g., user is not authenticated):
    M1 → M2 ⛔ return response immediately
        skips M3, M4, and the View
    ← M2 ← M1 ← Response

Real Examples of Short-Circuiting:
* AuthenticationMiddleware
If the user is not authenticated and tries to access a protected view, the middleware (or one of its
wrappers like LoginRequiredMixin) may return a redirect to the login page before the view runs.

* CORSMiddleware
If a request doesn’t meet CORS policy, it can return an HTTP 403/400 response without calling the view.


Step-4: View is Called
After passing through all middleware, the view function is finally executed. It returns an HttpResponse.


Step-5: Response Travels Back Through Middleware (Bottom-Up)
Once the view returns a response, the response travels back up through the middleware stack, like this:
    view returns response
      ↑
    M4 processes response
      ↑
    M3 processes response
      ↑
    M2 processes response
      ↑
    M1 processes response
      ↑
    final response returned to client
If middleware defines a process_response() or does something after calling get_response(), it can modify
the response before it is returned.


Step-6: Response Sent to Client
    * After the final response leaves the outermost middleware (M1), it returns to Django.
    * Django returns it to the WSGI/ASGI server.
    * The HTTP server sends the response to the original client.

--> 3 Main Point :
    1. Middleware is like layers of an onion — the request enters through the outer layer and goes deep
       into the core (view), and the response comes back out layer by layer.

    2. We define middleware in the order we want them executed on the request.

    3. Django builds the chain in reverse so the first one in your list wraps the entire stack and runs
       first.

