# Link : https://docs.djangoproject.com/en/5.2/topics/db/queries/
# Project Link : my_mac/test_project/orm_practice

Q : What is a data model?
-> A Django model is a Python class that represents a table in database. Each attribute of the model class represents a
database column, and each instance of that class represents a row in that table.

Model = Python class → Database table

Q : What is ORM (Object-Relational Mapping)?
-> ORM stands for Object-Relational Mapper. It’s a bridge between Python objects and database tables.
It allows us to interact with the database using Python code instead of writing raw SQL.

The ORM converts:
- Python code → SQL queries
- Database results → Python objects

Q : What is the Database Abstraction API?
-> Django’s Database Abstraction API is the set of Python methods and classes that let us interact with the database using
the ORM. It is the interface layer provided by Django ORM that abstracts (hides) SQL details and exposes high-level methods
like .filter(), .get(), .exclude(), .all() etc.

# Example
Student.objects.all()                # SELECT * FROM student;
Student.objects.filter(roll=101)     # SELECT * FROM student WHERE roll=101;
Student.objects.exclude(department='CSE')
Student.objects.get(pk=1)

Each of these methods is part of the database abstraction API. So Database Abstraction API is a collection of Pythonic
methods that make the ORM work without needing SQL directly.

Q : What is a Model Manager?
-> A Model Manager is a Python object through which Django’s ORM accesses the database for a particular model. By default,
every Django model automatically gets a manager named objects.

-> Once created a data models, Django automatically gives a database-abstraction API that lets us create, retrieve, update
and delete objects.

-> the Model Manager (like objects) is a part of Django’s Database Abstraction API. It acts as the entry point to the
database abstraction layer.

So,
1. Model: Defines a table (like Student)
2. Manager: Provides an entry point to perform queries (Student.objects)
3. QuerySet: Represents a collection of objects from the database (Student.objects.all())
4. ORM: converts the QuerySet to SQL
5. Database: executes the SQL and returns results

Q : What is QuerySet?
-> A QuerySet in Django is a lazy, iterable representation of a database query. That defines what data to retrieve from
the database — not the data itself — until it is evaluated. When evaluated, the ORM executes the corresponding SQL query
and returns the results as Python model objects.

-> Django’s ORM (Object-Relational Mapper) is the internal system that takes the QuerySet generated by the Manager and
converts it into SQL to communicate with the database.

-> A QuerySet is lazy: creating it (e.g., MyModel.objects.filter(...)) does not hit the database yet. When a QuerySet is
“evaluated” (for example by iterating over it, converting to list, slicing, calling len(), etc.), that triggers the ORM
to execute the SQL query. The result of that execution is that the rows returned by the SQL query are converted into
Python model instances (objects of your model class).

Thus: Manager → QuerySet → ORM constructs SQL → Database executes → ORM constructs python model objects → we get results.


# Object Create :
>>> b = Blog(name="Anik Blog", tagline="All the latest news.")
>>> b.save()

>>> a = Author(name="Jony", email="jony@gmail.com")
>>> a.save()

>>> e = Entry(blog=b, headline="Blog and Author", body_text="Body", pub_date=date(2024, 4, 12))
>>> e.save()
>>> e.authors.add(a)        # The add() method directly writes to the database. so don't need save here.

This performs an INSERT SQL statement behind the scenes. Django doesn’t hit the database until we explicitly call save().
The save() method has no return value.

# Update Exist Object :
>>> b.name = "Sourov Blog"
>>> b.save()

This performs an UPDATE SQL statement behind the scenes. Django doesn’t hit the database until we explicitly call save().

# Foreign Key Update:
>>> b_2 = Blog(name="Bangladesh Blog", tagline="Nothing To Say")
>>> b_2.save()
>>> e.blog = b_2
>>> e.save()

# ManyToManyField Fields Update
>>> jeo = Author.objects.create(name="jeo")
>>> e.authors.add(jeo)

# Saving ManyToManyField fields
>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> e.authors.add(john, paul, george, ringo)

# Retrieving objects
To retrieve objects from database, construct a QuerySet via a Manager(objects) on model class. A QuerySet represents a
collection of objects from database. In SQL terms, a QuerySet equates to a SELECT statement, and a filter is a limiting
clause such as WHERE or LIMIT.

# Blog.objects.all()
Blog.objects.all() returns a QuerySet, not the actual results (objects) immediately. When we call :
    blogs = Blog.objects.all()
Django does not immediately hit the database. Instead, it creates a QuerySet object, which is a lazy representation of
our query. That means it stores the SQL query Django will run, but doesn’t execute it yet.

Q : What is a QuerySet?
-> A QuerySet is like a collection of database queries that we can filter, slice, or chain before actually retrieving the data.

# Example :
qs = Blog.objects.all()                 # Creates a QuerySet (no query yet)
filtered_qs = qs.filter(active=True)    # Still a QuerySet (no query yet)
blogs = list(filtered_qs)               # Now the query runs, data fetched

Q : When does the database query actually run?
The query executes (fetches real objects) only when the QuerySet is evaluated. Evaluation happens in any of these cases:

1. When we iterate over it:
for blog in Blog.objects.all():
    print(blog.name)

2. When we convert it to a list:
blogs = list(Blog.objects.all())

3. When we access an item:
blog = Blog.objects.all()[0]

4. When we use methods that require actual data such as:
Blog.objects.all().count()
Blog.objects.all().exists()
Blog.objects.all().first()
Blog.objects.all().last()


# Retrieving specific objects with filters
The two most common ways to refine a QuerySet are:
1. filter(**kwargs) : Returns a new QuerySet containing objects that match the given lookup parameters.
2. exclude(**kwargs) : Returns a new QuerySet containing objects that do not match the given lookup parameters.


# Retrieving a single object with get()
.get() is used to retrieve a single object from the database that matches the given lookup parameters.
- If more than one object matches → it raises MultipleObjectsReturned.
- If no object matches → it raises DoesNotExist.

# Example-1
>>> e1 = Entry.objects.get(pk=1)

# Example-2
>>> e2 = Entry.objects.get(blog=b1, rating=9)
